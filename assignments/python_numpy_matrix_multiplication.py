# -*- coding: utf-8 -*-
"""Python_Numpy_Matrix_multiplication

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lqhUgO3Rlj414jcY0qlwKsu6psFGn5VY

----

<i>General instructions for this and future notebooks:</i>
1. To run a cell and move to the next cell: Hold down <strong>Shift</strong> and press <strong>Enter</strong>
2. To run a cell and stay in the same cell: Hold down <b>Ctrl</b> and press <b>Enter</b>
3. Use the arrow up and down to navigate or do it manually as you prefer
4. Escape from typing a cell: Hit <b>Esc</b>

---------

<b>Note: </b>

> You must run/evaluate all cells. <b>Order of cell execution is important.</b>



> You need to work direclty out of a copy of the assignment notebook given to you in the exact orer.

The first part walks you through some elements of Python/Numpy. It is meant mostly to familiarize you with Jypyter notebooks. It includes cells for demonstration, leading to clearly-marked cells for questions.

-----------------------

### **Part 1: NumPy walk-through**

Let's look at matrix A and how it is presented in Numpy
\begin{equation*}
A =
\begin{pmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{pmatrix}
\end{equation*}
"""

import numpy as np

# here the notation np.X invokes a function X from module np
#    where np is an alias for numpy as note in line-1 above.

A = np.array([[1,2,3],[4,5,6],[7,8,9]], dtype = np.float)
print('This is how matrix A will be presented in Numpy:\n\n {}\n'.format(A))

# Example of describing A
print('We just create a {}'.format(type(A)))
print('Our template has shape as {} with total size of {}'.format(A.shape, A.size))
print('The total dimension of A is {}'.format(A.ndim))

# Multi-line print out
print('''The data types of elements of A are {},
        which consumes {} bytes'''.format(A.dtype, A.nbytes))

# create a copy of A with integer type
A_copy = np.array(A, dtype=np.int32)

"""#### NumPy array operations"""

# Turn a python list to numpy array
checking_acct = [10.1, 2.3, -3, 100]
checking_acct_array = np.asarray(checking_acct)
type(checking_acct_array)

# adding $2 to each deposit/withdrawl transaction
checking_acct_array + 2

# subtract $0.5 from each transaction
checking_acct_array - 0.5

# double it up
checking_acct_array * 2

# divide the amounts by 3
checking_acct_array / 3

"""Note: You can't do the above operation with list. You will have to iterate the list's elements. For example"""

# to add $2 to each transaction with checking_acct, we must use list comprehension.
[x + 2 for x in checking_acct]

# create a one-dimensional array containing 10 ones
np.ones(10)

# create an identity matrix
np.identity(4)

# create an array size 1 x 9 including only even number starting from 2
x = np.arange(2,20,2)
x

# reshape x to size 3 x 3 we get the following matrix

# Variables in Python (an numpy) are objects.
# Each object contains data (like x does), but it is also associated
# with methods, i.e. python functions that can apply to it.
# When we apply such an operation, we use the notation x.fname, like
# below.

x = x.reshape(3,3)
x

# transpose x
y = x.T

# compare two arrays
x == y

x == y.T

np.array_equal(x,y.T)

x < y

c = np.ones((3,3))
c

# matrix squaring
np.dot(c,c)

# or
np.matmul(c,c)

# stacking/merging two multidimensional arrays
x = np.arange(10).reshape(2,5)
y = np.arange(15).reshape(3,5)
xy = np.vstack((x,y))
xy

x = np.arange(10).reshape(5,2)
y = np.arange(15).reshape(5,3)
xy = np.hstack((x,y))
xy

# checking statistics for xy
from scipy import stats
stats.describe(xy)

# generate 20 random records, each has 3 features represented by some random number
x = np.random.rand(20,3)

# check statistics by feature for these records
n, min_max, mean, var, skew, kurt = stats.describe(x)

# observe the gather statistics
print('''x:\n {}\n\n,n:\n {}\n\n, min_max:\n {}\n\n, mean:\n {}\n\n
, var:\n {}\n\n, skew:\n {}\n\n, kurt:\n {}\n\n'''.format(x, n, min_max, mean, var, skew, kurt))

"""#### Slice and dice matrix

Take out 2 elements in 1st row, 2nd column, and 3rd row, 3rd column of matrix A from above

$\begin{equation*}
A =
\begin{pmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{pmatrix}
\end{equation*}
$
"""

# numpy is indexed from 0. Slice by row and then by column
A[[0,2],[1,2]]

"""#### Resize and reshape matrix
Matrix will be truncated or element values will be repeated if the reshape makes the matrix to be a bigger matrix.
"""

x = (np.arange(9)+1).reshape(3,3)
print(x)
print('\nresize smaller\n {}'.format(np.resize(x,(2,2))))
print('\nresize bigger\n {}'.format(np.resize(x,(4,4))))

"""#### Multiplying two matrices
An 1-dimensional array is treated as a vector
"""

# a vector/array y
y = np.arange(4)
y

# a matrix of ones
x = np.ones(16).reshape(4,4)
x

x*y

x*y.T   # interpreted as x*(y.T)

y*x

y.T*x

x = np.arange(4).reshape(2,2)
y1 = np.arange(2)
y2 = np.arange(2).reshape(1,2) # in numpy this is the same as y1
print('x:\n{}\n'.format(x))
print('y1:\n{}\n'.format(y1))
print('y2:\n{}\n'.format(y2))

x*y1

x*y2

# generate two matrices
a = np.arange(10).reshape(2,5)
b = np.arange(15).reshape(5,3)
print(a)
print()
print(b)

# check if operation dot is equal to operation matmul
np.array_equal(np.dot(a,b),np.matmul(a,b))

# multiple a by b
np.matmul(a,b)

# another way to multiply a by b
a@b

a = np.arange(9).reshape(3,3)
b = np.arange(3)
print('{}\n\n{}'.format(a,b))

# inner product of 2 vectors
np.inner(a,b)

# outer product of 2 vectors
np.outer(a,b)

"""#### Solving linear equations
An example: Solve three linear equations with 3 unknowns as follows:<br>
$x_1 + 2x_2 + 3x_3 = 10$<br>
$4x_1 + 4x_2 + 5x_3=4$<br>
$3x_1 + 8x_2 + 9x_3 = 3$<br>

We have a linear equation to solve as in the form $Ax = B$ where
\begin{equation*}
A =
\begin{pmatrix}
1 & 2 & 3 \\
4 & 4 & 5 \\
3 & 8 & 9
\end{pmatrix}
,
B =
\begin{pmatrix}
10 \\
4 \\
3
\end{pmatrix}
,
x =
\begin{pmatrix}
x_1 \\
x_2 \\
x_3
\end{pmatrix}
\end{equation*}

<br>
In simple cases with small matrices, we can do $x = A^{-1}B$
"""

A = np.array([[1,2,3],[4,4,5],[3,8,9]])
B = np.array([10,4,3])
A_inv = np.linalg.inv(A)
A_inv

x = np.dot(A_inv, B)

# check results with allclose() function)
np.allclose(np.dot(A,x),B)

"""-----

## <font color='#008DFF'> **Question 1**

Write code for solving four linear equations with 4 unknowns as follows:<br>
$x_1 + 2x_2 + 3x_3 + 5x_4 = 10$<br>
$4x_1 + 4x_2 + 5x_3 + 3x_4=4$<br>
$3x_1 + 8x_2 + 9x_3 + x_4= 3$<br>
$x_1 + x_2 + 3x_3 = 7$<br><br>

Afterwards, check results with allclose( ) function. And print out x.

<b>Expected result</b><br>x = array([-1.17857143, -3.875     ,  4.01785714,  1.375     ])
"""

# your code here

# Initializing matrices
A = np.array([[1,2,3,5], [4,4,5,3], [3,8,9,1], [1,1,3,0]])
B = np.array([10,4,3,7])

# Calculating inverse of A matrix using inv() function
A_inv = np.linalg.inv(A)
A_inv

x = np.dot(A_inv, B)
print('X: \n', x)

# check results with allclose() function)
np.allclose(np.dot(A,x),B)

# Grader's area
#
# Here we have only part, so this grade is assigned in M[1,1]
# assign the grade and then uncomment the following

# M[1,1] =

maxScore = maxScore +4;

"""-----------------
-----------------
-----------------
-----------------

## **Part 2: Exploring some data**

In this exercising we will be using the 'Boston Housing' dataset. This is an infamous dataset because one of the attributes of the data points is the percentage of black people in a town. This dataset has now been removed from official distributions of certain tools, but it is still around to remind us how human learned bias can enter Machine Learning pipelines and have unintened (or in some cases, horribly intended) consequences.
"""

from sklearn.datasets import load_boston
ds = load_boston()
samples, label, feature_names = ds.data, ds.target, ds.feature_names
print(samples.shape)
print(feature_names)

# Data description
print(ds.DESCR)

# check to see if there is any null data
np.isnan(np.sum(samples))

# set print options to make things look nicer
np.set_printoptions(suppress=True, linewidth=125)

# find median, variance of the data and put it out in nice looking format
median = np.round(np.median(samples, axis=0), decimals=1)
variance = np.round(np.var(samples, axis=0), decimals=1)
basic_stats = np.vstack((median, variance))
basic_stats_label = ['  median','variance']
print('\t\tCRIM\tZN\tINDUS\tCHAS\tNOX\tRM\tAGE\tDIS\tRAD\tTAX\tPTRATIO\tB\tLSTAT')
for basic_stats_label, row in zip(basic_stats_label, basic_stats):
    print('{} [\t{}]'.format(basic_stats_label,"".join('%s\t'%i for i in row)))

"""## <font color='#008DFF'>  **Question 2**

Use function <code>stats.describe</code> to retrieve the max min and average of samples then display it as in the expected output <br><br>

<b>Expected Output:</b> Something that looks like the following or better: <br>
<code>	 CRIM	ZN	INDUS	CHAS	NOX	RM	AGE	DIS	RAD	TAX	PTRATIO	B	LSTAT
 min [	0.0	0.0	0.5	0.0	0.4	3.6	2.9	1.1	1.0	187.0	12.6	0.3	1.7	]
 max [	89.0	100.0	27.7	1.0	0.9	8.8	100.0	12.1	24.0	711.0	22.0	396.9	38.0	]
mean [	3.6	11.4	11.1	0.1	0.6	6.3	68.6	3.8	9.5	408.2	18.5	356.7	12.7	]
</code>

<b>Answer</b>:
"""

# Your code here. Add more cells if needed
n, min_max, mean, var, skew, kurt = stats.describe(samples)

basic_stats = np.round(np.vstack((min_max, mean)),1)
basic_stats_label = ['min ', 'max ', 'mean']

print('\t\tCRIM\tZN\tINDUS\tCHAS\tNOX\tRM\tAGE\tDIS\tRAD\tTAX\tPTRATIO\tB\tLSTAT')
for basic_stats_label, row in zip(basic_stats_label, basic_stats):
    print('\t{} [\t{}]'.format(basic_stats_label,"".join('%s\t'%i for i in row)))

# Grader's area

maxScore = maxScore + 4
# M[2,1] =

"""-----------------
-----------------
-----------------
-----------------
"""

import matplotlib.pyplot as plt

# let plot out to see what is the distribution of crime based on the data
n, bins, patches = plt.hist(samples[:,0],bins='auto')
plt.title('Distribution of crimes')
plt.show()
print('Bin sizes: {}'.format(n))

"""
## <font color='#008DFF'> <b>Question 3</b>

Plot out the histogram of another feature of the dataset that you are interested in, give the plot a title and also print out the bin sizes <br><br>
<b>Answer</b>"""

# Your code here, add more cells if necessary

# Plotting histogram for 2nd column - ZN
n, bins, patches = plt.hist(samples[:,1],bins='auto')
plt.title('Distribution of residential land zoned for lots over 25,000 sq.ft')
plt.show()
print('Bin sizes: {}'.format(n))

# Grader's area

maxScore = maxScore+4
# M[3,1] =

"""------------------
------------------
------------------
------------------





"""

def house_with_defined_age(dataset,age):
    '''This function will return indices of all house with proportion of owner-occupied units built prior to 1940 greater than age%'''
    ids = []
    for id, record in enumerate(dataset):
        if record[6]>age:
            ids.append(id)
    return ids


# list out all records with units built prior to 1940 greater than 50%
samples[house_with_defined_age(samples,50)]

"""
## <font color='#008DFF'> **Question 4**

Write a function that takes as input the given dataset, and two numbers $a$ and $b$, and returns the ids of houses that tax is either less than $a$ or more than $b$. Demonstrate how the function runs with two specific inputs $a$ and $b$ of your choice.

"""

# your code goes here

def house_with_defined_tax_range(dataset,a,b):
    ids = []
    for id, record in enumerate(dataset):
        if record[9]<a or record[9]>b:
            ids.append(id)
    return ids


samples[house_with_defined_tax_range(samples,200,300)]

# Grader's area

maxScore = maxScore + 4
# M[4,1]=

"""------------------------------------------
------------------------------------------
------------------------------------------
------------------------------------------

## **Part 3: kNN simple implementation**

Here we work with a simple implementation of kNN in order to understand how objects and methods work

## <font color='#008DFF'> **Question 5**
"""

# the following algorithm is an implementation of the kNN pseudocode we discussed in the lecture

class kNN_classifier:
  # the hyperparameters that define the object/algorithm
  # these are given at initialization
  def __init__(self,k, distance='euclidean'):
    self.k = k
    self.distance = distance


  #here we define the methods of the knn classifier object

  #the fit method takes as input the data and labels
  def fit(self,X,y):
    # siply save X, y as part of the object
    # y is assumed to have labels 0 or 1 (binary classifier)
    self.X = X
    self.y = y



  def predict(self,x):

    # here we expect x to be a row vector of the same
    # dimension as the rows of X. no checks are done.

    n = self.X.shape[0]
    S = []
    for j in range(n):

      if self.distance =='euclidean':
        dst = np.linalg.norm(x-self.X[j,:])

      S.append(dst)

    # sort distances
    prm = np.argsort(S)


    c = 0
    for j in range(self.k):
      idx = prm[j]
      if self.y[idx] == 1:
        c = c+1

    if c >= self.k//2:
      return 1
    else:
      return 0

"""### <font color='#008DFF'>  **Question 5(i)**

Re-use the code from the beggining of [notes](https://colab.research.google.com/drive/1NIHv_CoknQt3UcrMSezu7iUJEsEeyaaN?usp=drive_fs) from module 1 (Introduction) in order to create a simple dataset with 2 blobs/clusters. Check if the labels vectors contains 0s and 1s as needed by our kNN code.
"""

import sklearn

## your code goes here

# Populating data using make_blobs() function
X, y = sklearn.datasets.make_blobs(n_features=2, centers=2, random_state = 51)
plt.scatter(X[:, 0], X[:, 1], c=y)
# The plot shows only two colors which means that there are only two different labels

# Checking if the labels only contain 0 or 1 value. Returns TRUE if condition is met.
np.all((y == 0) | (y == 1))

"""### <font color='#008DFF'>  **Question 5(ii)**

Initialize a kNN classifier using the class we wrote above. (Hint: see the kNN lab on how to initialize an object)
"""

## your code goes here


knn = kNN_classifier(2)

knn.fit(X,y)

print('KNN model prediction: ', knn.predict(X[0]))

print('Actual label: ', y[0])

# Grader's area

maxScore = maxScore +5
#M[5,2] =

"""### <font color='#008DFF'>  **Question 5(iii)**

Add code in the kNN classifier defined above, in order to handle the case when the hyperparameter *distance* is set to 'Manhattan'
"""

## your additional code goes here.
## Please make a comment about where it should be added in the original code above

# In the for loop we can add another if statement to handle distance='manhattan'


class kNN_classifier:
  # the hyperparameters that define the object/algorithm
  # these are given at initialization
  def __init__(self,k, distance='euclidean'):
    self.k = k
    self.distance = distance


  #here we define the methods of the knn classifier object

  #the fit method takes as input the data and labels
  def fit(self,X,y):
    # siply save X, y as part of the object
    # y is assumed to have labels 0 or 1 (binary classifier)
    self.X = X
    self.y = y



  def predict(self,x):

    # here we expect x to be a row vector of the same
    # dimension as the rows of X. no checks are done.

    n = self.X.shape[0]
    S = []
    for j in range(n):

      if self.distance =='euclidean':
        dst = np.linalg.norm(x-self.X[j,:])

#     ---------------------------------------------------------------------------------------------------
#     Added code
      elif self.distance == 'manhattan':
        dst = np.linalg.norm(x-self.X[j,:], ord=1)

#     ---------------------------------------------------------------------------------------------------
      S.append(dst)

    # sort distances
    prm = np.argsort(S)


    c = 0
    for j in range(self.k):
      idx = prm[j]
      if self.y[idx] == 1:
        c = c+1

    if c >= self.k//2:
      return 1
    else:
      return 0

# Initializing knn model with distance='manhattan'
knn1 = kNN_classifier(2, 'manhattan')

knn.fit(X,y)

print('KNN model prediction using Manhattan distance formula: ', knn.predict(X[0]))

print('Actual label: ', y[0])

"""----------------------
----------------------
----------------------
"""